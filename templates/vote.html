<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Votação - SchulzeVote</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <style>
    .grid { display:grid; gap:10px; grid-template-columns: 1fr 120px; align-items:center; }
    .row { display:contents; }
    .hdr { font-weight:bold; }
    .special { background:#111827; color:#fff; padding:6px 10px; border-radius:6px; }
    .special-null { background:#991b1b; color:#fff; padding:6px 10px; border-radius:6px; }
    .muted { color:#6b7280; }
    .sep { margin:14px 0; border-top:1px solid #e5e7eb; }
    input[type="number"] { width:100%; padding:6px 8px; border:1px solid #d1d5db; border-radius:8px; }
    input[disabled] { background:#f3f4f6; }
    .warn { color:#b45309; margin-top:6px; }
    .ok { color:#059669; margin-top:6px; }
    .error { color:#b91c1c; margin-top:6px; }
    .badge { display:inline-block; background:#eef2ff; color:#3730a3; padding:2px 8px; border-radius:999px; margin-left:6px; font-size:.85rem; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Votação <span class="badge">preferências por número</span></h1>

    <form method="POST" id="voteForm">
      <label for="voter_id"><b>Sua chave de eleitor</b></label><br>
      <input type="text" id="voter_id" name="voter_id" required><br><br>

      <p class="muted">
        Digite <b>1</b> para sua primeira preferência, <b>2</b> para a segunda, e assim por diante.
        Você pode <b>deixar candidatos sem número</b>; eles irão para o <b>final</b> automaticamente (menos preferidos).
      </p>

      <div class="grid hdr">
        <div>Candidato</div>
        <div>Preferência</div>
      </div>

      <div id="candGrid" class="grid">
        {% for c in candidates %}
          {% set is_blank = (c == "Voto em Branco") %}
          {% set is_null = (c == "Voto Nulo") %}
          <div class="row">
            <div>
              {% if is_blank %}
                <span class="special">{{ c }}</span>
              {% elif is_null %}
                <span class="special-null">{{ c }}</span>
              {% else %}
                {{ c }}
              {% endif %}
              <input type="hidden" name="cand_{{ loop.index0 }}" value="{{ c }}">
            </div>
            <div>
              <input type="number" min="1" step="1" inputmode="numeric"
                     name="rank_{{ loop.index0 }}" class="rank-input"
                     data-candidate="{{ c }}">
            </div>
          </div>
        {% endfor %}
      </div>

      <div id="statusBox" class="muted" style="margin-top:8px;"></div>

      <div class="sep"></div>

      <p><b>Atalho:</b> você pode marcar um destes e ignorar os números acima:</p>
      <label>
        <input type="radio" name="special_vote" value="BLANK"> Votar em <b>Voto em Branco</b>
      </label><br>
      <label>
        <input type="radio" name="special_vote" value="NULL"> Votar em <b>Voto Nulo</b>
      </label><br>
      <label>
        <input type="radio" name="special_vote" value="" checked> Nenhum (usarei os números acima)
      </label>

      <!-- campo oculto onde o JS montará a ordem final -->
      <div id="ranking-fields"></div>

      <br>
      <button type="submit" class="button">Enviar voto</button>
    </form>
  </div>

  <script>
    const form = document.getElementById("voteForm");
    const fields = document.getElementById("ranking-fields");
    const rankInputs = Array.from(document.querySelectorAll(".rank-input"));
    const specialRadios = Array.from(document.querySelectorAll('input[name="special_vote"]'));
    const statusBox = document.getElementById("statusBox");

    function getCandidates() {
      const names = [];
      for (let i = 0; ; i++) {
        const el = form.querySelector(`input[name="cand_${i}"]`);
        if (!el) break;
        names.push(el.value);
      }
      return names;
    }

    function setDisabledRanks(disabled) {
      rankInputs.forEach(inp => { inp.disabled = disabled; if (disabled) inp.value = ""; });
      updateStatus(); // atualiza mensagens
    }

    function updateSpecialMode() {
      const val = (specialRadios.find(r => r.checked) || {}).value || "";
      if (val === "BLANK" || val === "NULL") {
        setDisabledRanks(true);
      } else {
        setDisabledRanks(false);
      }
    }
    specialRadios.forEach(r => r.addEventListener("change", updateSpecialMode));
    updateSpecialMode();

    function buildRankingFromNumbers(allowPartial=true) {
      const entries = [];
      const blanks = [];
      const dupMap = new Map(); // rank -> [cands]

      for (let i = 0; ; i++) {
        const nameEl = form.querySelector(`input[name="cand_${i}"]`);
        const rankEl = form.querySelector(`input[name="rank_${i}"]`);
        if (!nameEl || !rankEl) break;

        const cand = nameEl.value;
        const val  = rankEl.value.trim();

        if (!val) {
          if (!allowPartial) {
            return { ok:false, msg:"Preencha todas as preferências (1, 2, 3, ...)." };
          } else {
            blanks.push(cand);
            continue;
          }
        }
        const n = Number(val);
        if (!Number.isInteger(n) || n < 1) {
          return { ok:false, msg:`Valor inválido para "${cand}". Use inteiros ≥ 1.` };
        }
        entries.push({ cand, rank: n });
        const list = dupMap.get(n) || [];
        list.push(cand);
        dupMap.set(n, list);
      }

      // valida duplicatas se o eleitor NUMEROU algum candidato
      const hasAnyNumber = entries.length > 0;
      let duplicates = [];
      for (const [r, lst] of dupMap.entries()) {
        if (lst.length > 1) duplicates = duplicates.concat(lst.map(c => `${c} (nº ${r})`));
      }
      if (hasAnyNumber && duplicates.length > 0) {
        return { ok:false, msg:"Números repetidos: " + duplicates.join(", ") };
      }

      // ordena por rank
      entries.sort((a,b)=>a.rank-b.rank);

      // não numerados vão para o final em ORDEM ALFABÉTICA,
      // garantindo “Voto em Branco” acima de “Voto Nulo”, se existirem
      const RESERVED_BLANK = "Voto em Branco";
      const RESERVED_NULL  = "Voto Nulo";

      const blanksCore = blanks.filter(c => c !== RESERVED_BLANK && c !== RESERVED_NULL)
                               .sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:"base"}));
      const addReserved = [];
      if (blanks.includes(RESERVED_BLANK)) addReserved.push(RESERVED_BLANK);
      if (blanks.includes(RESERVED_NULL))  addReserved.push(RESERVED_NULL);

      const ranking = entries.map(e=>e.cand).concat(blanksCore, addReserved);
      return { ok:true, ranking, info: { filled: entries.length, total: entries.length + blanks.length, blanks: blanks.length } };
    }

    function buildRankingSpecial(which) {
      const all = getCandidates();
      let pick = (which === "BLANK") ? "Voto em Branco" : "Voto Nulo";
      if (!all.includes(pick)) {
        return { ok:false, msg:`Opção especial "${pick}" não encontrada.` };
      }
      return { ok:true, ranking:[pick], info: { filled: 1, total: 1, blanks: 0 } };
    }

    function writeHiddenRanking(list) {
      fields.innerHTML = "";
      list.forEach(name => {
        const inp = document.createElement("input");
        inp.type = "hidden";
        inp.name = "ranking";
        inp.value = name;
        fields.appendChild(inp);
      });
    }

    function updateStatus() {
      const val = (specialRadios.find(r => r.checked) || {}).value || "";
      if (val === "BLANK" || val === "NULL") {
        statusBox.innerHTML = '<span class="ok">Modo especial selecionado. Os campos numéricos foram desativados.</span>';
        return;
      }

      // modo normal (numérico)
      const entries = [];
      const filledRanks = new Set();
      let total = 0, filled = 0, dupCount = 0;

      for (let i = 0; ; i++) {
        const nameEl = form.querySelector(`input[name="cand_${i}"]`);
        const rankEl = form.querySelector(`input[name="rank_${i}"]`);
        if (!nameEl || !rankEl) break;
        total++;
        const val = rankEl.value.trim();
        if (val) {
          filled++;
          if (filledRanks.has(val)) dupCount++;
          filledRanks.add(val);
        }
      }

      if (dupCount > 0) {
        statusBox.innerHTML = '<span class="warn">Atenção: há números repetidos.</span>';
      } else if (filled === 0) {
        statusBox.innerHTML = '<span class="muted">Você pode numerar alguns candidatos e deixar outros em branco (eles irão para o final).</span>';
      } else {
        const missing = total - filled;
        if (missing === 0) {
          statusBox.innerHTML = '<span class="ok">Tudo preenchido. Sem duplicatas.</span>';
        } else {
          statusBox.innerHTML = `<span class="muted">Faltam ${missing} candidato(s) sem número. Eles irão para o final automaticamente.</span>`;
        }
      }
    }

    rankInputs.forEach(inp => inp.addEventListener("input", updateStatus));
    updateStatus();

    form.addEventListener("submit", (e) => {
      const choice = (specialRadios.find(r => r.checked) || {}).value || "";
      let res;
      if (choice === "BLANK" || choice === "NULL") {
        res = buildRankingSpecial(choice);
      } else {
        res = buildRankingFromNumbers(true); // aceita ranking parcial
      }
      if (!res.ok) {
        e.preventDefault();
        alert(res.msg);
        return;
      }
      writeHiddenRanking(res.ranking);
    });
  </script>
</body>
</html>
