{% extends "base.html" %}
{% block title %}SchulzeVote · Guia completo do método de Schulze{% endblock %}

{% block content %}
<div class="wrap">
  <h1>Guia do método de Schulze</h1>
  <p class="muted">
    Este guia explica o funcionamento do método de Schulze (votação por preferências), com visão rápida,
    definição formal, exemplos (incluindo ciclo), critérios de desempate, votos parciais, e como tratamos
    <b>Voto em Branco</b> e <b>Voto Nulo</b>. No fim há um <b>simulador interativo</b>.
  </p>

  <!-- Sumário -->
  <div class="card">
    <h3 style="margin:0 0 10px 0">Sumário</h3>
    <div class="row" style="flex-wrap:wrap;gap:8px">
      <a class="btn ghost" href="#visao-geral">Visão geral</a>
      <a class="btn ghost" href="#definicao-formal">Definição formal</a>
      <a class="btn ghost" href="#exemplo-simples">Exemplo simples</a>
      <a class="btn ghost" href="#exemplo-ciclo">Exemplo com ciclo</a>
      <a class="btn ghost" href="#empates">Empates e critérios</a>
      <a class="btn ghost" href="#parciais">Votos parciais/ausentes</a>
      <a class="btn ghost" href="#branco-nulo">Branco e Nulo</a>
      <a class="btn ghost" href="#auditoria">Auditoria pública</a>
      <a class="btn ghost" href="#faq">FAQ</a>
      <a class="btn accent" href="#simulador">Simulador</a>
    </div>
  </div>

  <!-- Alternador Resumo / Detalhado -->
  <div class="card">
    <div class="row" style="justify-content:space-between;align-items:center">
      <div><b>Modo de leitura</b></div>
      <div class="row">
        <button class="btn" onclick="setMode('resumo')">Resumo</button>
        <button class="btn ghost" onclick="setMode('detalhado')">Detalhado</button>
      </div>
    </div>
    <p id="modeTip" class="muted" style="margin-top:8px"></p>
  </div>

  <!-- Visão geral -->
  <div id="visao-geral" class="card mode-resumo mode-detalhado">
    <h2 style="margin-top:0">Visão geral (como o eleitor vota e como contamos)</h2>
    <ul>
      <li><b>Você ordena candidatos</b> conforme preferência: 1º, 2º, 3º… (ranking). Pode deixar alguns sem número (parcial).</li>
      <li>Comparamos candidatos <b>par a par</b> para contar quantos eleitores preferem A a B, B a C etc.</li>
      <li>Calculamos os <i>caminhos mais fortes</i> entre pares usando essas vitórias diretas.</li>
      <li>O(s) <b>vencedor(es) de Schulze</b> são aqueles que não são “derrotados” por nenhum outro candidato quando
          consideramos o melhor caminho de vitórias que vai de um ao outro.</li>
    </ul>
    <p class="muted">
      Intuição: se A não vence B diretamente, talvez A vença C fortemente e C vença B fortemente;
      esse “caminho” A→C→B pode ser tão ou mais forte que o caminho de volta B→…→A. O Schulze compara essas forças.
    </p>

    <!-- Figura: Fluxo geral -->
    <figure class="card" style="text-align:center">
      <img loading="lazy"
           src="{{ url_for('static', filename='img/schulze_flow_overview.png') }}?v={{ APP_VERSION }}"
           alt="Fluxo geral do método de Schulze"
           style="max-width:100%;height:auto">
      <figcaption class="muted" style="margin-top:6px">Fluxo geral do método de Schulze.</figcaption>
    </figure>
  </div>

  <!-- Definição formal -->
  <div id="definicao-formal" class="card mode-detalhado">
    <h2 style="margin-top:0">Definição formal (resumo técnico)</h2>
    <ol>
      <li><b>Preferência par-a-par</b>: para cada par distinto (a,b), defina <code>d[a][b]</code> como
          o número (ou soma de pesos) de eleitores que preferem a&gt;b.</li>
      <li><b>Força direta</b>: a força direta de a→b é <code>d[a][b]</code> se <code>d[a][b] &gt; d[b][a]</code>, senão 0.</li>
      <li><b>Caminho e sua força</b>: a força de um caminho a→…→b é o <b>mínimo</b> das forças diretas ao longo dele
          (princípio da “garrafa estreita”).</li>
      <li><b>Melhor caminho</b>: <code>p[a][b]</code> é a <b>máxima</b> força dentre todos os caminhos de a para b.</li>
      <li><b>Comparação final</b>: dizemos que a “não perde para b” se <code>p[a][b] ≥ p[b][a]</code>.
          Os vencedores são os candidatos que “não perdem para ninguém”.</li>
    </ol>
    <p class="muted">
      Observação: no Schulze clássico usa-se um algoritmo no estilo Floyd-Warshall para computar rapidamente <code>p[a][b]</code>.
    </p>

    <!-- Figura: Definição formal -->
    <figure class="card" style="text-align:center">
      <img loading="lazy"
           src="{{ url_for('static', filename='img/schulze_formal_definition.png') }}?v={{ APP_VERSION }}"
           alt="Definição formal — Schulze"
           style="max-width:100%;height:auto">
      <figcaption class="muted" style="margin-top:6px">Definição formal resumida.</figcaption>
    </figure>
  </div>

  <!-- Exemplo simples -->
  <div id="exemplo-simples" class="card mode-resumo mode-detalhado">
    <h2 style="margin-top:0">Exemplo simples (3 candidatos)</h2>
    <p>Suponha os votos (todos peso 1):</p>
    <ol>
      <li>A &gt; B &gt; C</li>
      <li>A &gt; C &gt; B</li>
      <li>B &gt; C &gt; A</li>
      <li>C &gt; B &gt; A</li>
      <li>A &gt; B &gt; C</li>
    </ol>
    <p><b>Par-a-par</b> (quantos preferem um ao outro):</p>
    <ul>
      <li>A×B: A=3, B=2 → força direta A→B=3</li>
      <li>A×C: A=3, C=2 → força direta A→C=3</li>
      <li>B×C: B=3, C=2 → força direta B→C=3</li>
    </ul>
    <p><b>Caminhos</b>: A vence B e C diretamente; B vence C. Logo <b>A</b> é vencedor de Schulze.</p>

    <!-- Figura: Exemplo simples -->
    <figure class="card" style="text-align:center">
      <img loading="lazy"
           src="{{ url_for('static', filename='img/schulze_example_simple.png') }}?v={{ APP_VERSION }}"
           alt="Exemplo simples com 3 candidatos"
           style="max-width:100%;height:auto">
      <figcaption class="muted" style="margin-top:6px">Exemplo simples (3 candidatos).</figcaption>
    </figure>
  </div>

  <!-- Exemplo com ciclo -->
  <div id="exemplo-ciclo" class="card mode-detalhado">
    <h2 style="margin-top:0">Exemplo com ciclo (A &gt; B, B &gt; C, C &gt; A)</h2>
    <p>Perfis (ilustrativos):</p>
    <ul>
      <li>40 eleitores: A &gt; B &gt; C</li>
      <li>35 eleitores: B &gt; C &gt; A</li>
      <li>25 eleitores: C &gt; A &gt; B</li>
    </ul>
    <p>Temos:</p>
    <ul>
      <li>A×B: A ganha (40+25 vs 35) → A→B = 65</li>
      <li>B×C: B ganha (40+35 vs 25) → B→C = 75</li>
      <li>C×A: C ganha (35+25 vs 40) → C→A = 60</li>
    </ul>
    <p>
      Há um <b>ciclo</b>. O Schulze escolhe o(s) vencedor(es) olhando os <b>melhores caminhos</b> entre cada par;
      quem tiver caminhos sempre tão fortes quanto os do oponente (ou mais) “não perde para ninguém”.
    </p>

    <!-- Figura: Ciclo -->
    <figure class="card" style="text-align:center">
      <img loading="lazy"
           src="{{ url_for('static', filename='img/schulze_example_cycle.png') }}?v={{ APP_VERSION }}"
           alt="Exemplo com ciclo"
           style="max-width:100%;height:auto">
      <figcaption class="muted" style="margin-top:6px">Exemplo de ciclo: A&gt;B, B&gt;C, C&gt;A.</figcaption>
    </figure>
  </div>

  <!-- Empates e critérios -->
  <div id="empates" class="card mode-detalhado">
    <h2 style="margin-top:0">Empates e critérios práticos</h2>
    <ul>
      <li><b>Empate par-a-par</b> (d[a][b] == d[b][a]): a força direta fica 0 para ambos.</li>
      <li><b>Vários vencedores</b>: pode ocorrer; a organização pode ter regra local (ex.: nova rodada entre eles).</li>
      <li><b>Exibição ordenada</b>: no nosso app, quando mostramos um “ranking geral”, usamos um score auxiliar:
        <i>wins</i> (quantos o candidato “bate” via p[a][b] &gt; p[b][a]) e <i>losses</i>.
        Ordenamos por (wins, -losses) para dar uma lista estável, mesmo havendo co-vencedores.</li>
    </ul>

    <!-- Figura: Empates -->
    <figure class="card" style="text-align:center">
      <img loading="lazy"
           src="{{ url_for('static', filename='img/schulze_tie.png') }}?v={{ APP_VERSION }}"
           alt="Critérios de desempate"
           style="max-width:100%;height:auto">
      <figcaption class="muted" style="margin-top:6px">Critérios de desempate no método de Schulze.</figcaption>
    </figure>
  </div>

  <!-- Parciais / Ausentes -->
  <div id="parciais" class="card mode-detalhado">
    <h2 style="margin-top:0">Votos parciais e ausências de ranking</h2>
    <p>
      É permitido <b>deixar candidatos sem número</b>. Eles não geram preferências contra os demais
      (tratamos como “ausente”, não como empate ativo). Isso é útil se você só quer ranquear os que conhece.
    </p>
    <ul>
      <li>Se A está ranqueado e B está ausente, conta como preferência A&gt;B.</li>
      <li>Se A e B estão ambos ausentes, não contribui para A×B.</li>
    </ul>
  </div>

  <!-- Branco / Nulo -->
  <div id="branco-nulo" class="card mode-resumo mode-detalhado">
    <h2 style="margin-top:0">Voto em Branco e Voto Nulo (no SchulzeVote)</h2>
    <p>
      No formulário sempre existem duas opções especiais ao final: <b>Voto em Branco</b> e <b>Voto Nulo</b>.
    </p>
    <ul>
      <li><b>Branco</b>: registra abstenção consciente. Você não apoia nenhum candidato.</li>
      <li><b>Nulo</b>: registro de protesto; não deseja que seu voto beneficie candidatos.</li>
    </ul>
    <p>
      Por <b>transparência</b>, essas opções aparecem na contagem como “candidatos especiais”.
      Se muitos eleitores escolhem exclusivamente Branco ou Nulo, eles podem aparecer no topo do ranking
      (sinalizando falta de apoio aos demais). Cabe à organização definir previamente o que fazer
      nesse caso (ex.: reabrir candidaturas, nova votação, quóruns etc.).
    </p>
    <p><b>Recomendação:</b> geralmente escolha <i>somente</i> Branco/Nulo <b>ou</b> ranqueie candidatos. Evite misturar.</p>

    <!-- Figura: Branco/Nulo -->
    <figure class="card" style="text-align:center">
      <img loading="lazy"
           src="{{ url_for('static', filename='img/schulze_blank_null.png') }}?v={{ APP_VERSION }}"
           alt="Tratamento de votos Branco e Nulo"
           style="max-width:100%;height:auto">
      <figcaption class="muted" style="margin-top:6px">Como tratamos Branco e Nulo: aparecem como “candidatos especiais”.</figcaption>
    </figure>
  </div>

  <!-- Auditoria -->
  <div id="auditoria" class="card mode-resumo mode-detalhado">
    <h2 style="margin-top:0">Auditoria pública</h2>
    <p>
      Após o encerramento, disponibilizamos:
    </p>
    <ul>
      <li><b>Resultados</b>: <code>/public/&lt;EID&gt;/results</code></li>
      <li><b>Log textual de auditoria</b>: <code>/public/&lt;EID&gt;/audit</code></li>
      <li><b>CSV auxiliares</b>: <code>/public/&lt;EID&gt;/results.csv</code> e <code>/public/&lt;EID&gt;/pairwise.csv</code></li>
      <li><b>Pacote ZIP de auditoria</b> (para admins): contém cédulas anônimas, log e manifest.</li>
    </ul>
    <p class="muted">As chaves de votação são “hashadas” no armazenamento de cédulas; não há identificação do eleitor na cédula.</p>

    <!-- Figura: Auditoria -->
    <figure class="card" style="text-align:center">
      <img loading="lazy"
           src="{{ url_for('static', filename='img/schulze_audit.png') }}?v={{ APP_VERSION }}"
           alt="Exemplo de auditoria pública"
           style="max-width:100%;height:auto">
      <figcaption class="muted" style="margin-top:6px">Exemplo de auditoria pública no SchulzeVote.</figcaption>
    </figure>
  </div>

  <!-- FAQ -->
  <div id="faq" class="card mode-detalhado">
    <h2 style="margin-top:0">FAQ / Boas práticas</h2>
    <ul>
      <li><b>Preciso ordenar todos?</b> Não. Pode ranquear só alguns.</li>
      <li><b>Posso repetir números?</b> Evite; use 1,2,3… sem empates.</li>
      <li><b>E se houver empate final?</b> Pode haver co-vencedores. A comissão define política local.</li>
      <li><b>O que guardar do processo?</b> Resultados, auditoria e o <i>bundle</i> de auditoria ao final.</li>
    </ul>
  </div>

  <!-- Simulador -->
  <div id="simulador" class="card mode-resumo mode-detalhado">
    <h2 style="margin-top:0">Simulador interativo (no seu navegador)</h2>
    <p class="muted">
      Edite candidatos e perfis; clique em <i>Calcular</i>. Nada é enviado ao servidor.
    </p>

    <!-- Config de candidatos -->
    <div class="card" style="background:#0f1216">
      <h3 style="margin:0 0 8px 0">Candidatos</h3>
      <div class="row" style="gap:8px;flex-wrap:wrap" id="candList"></div>
      <div class="row" style="margin-top:8px">
        <input id="newCand" type="text" placeholder="Novo candidato" style="min-width:220px">
        <a class="btn" href="#" onclick="addCand();return false;">Adicionar</a>
        <a class="btn ghost" href="#" onclick="resetCands();return false;">Resetar (A,B,C)</a>
      </div>
    </div>

    <!-- Perfis de preferência -->
    <div class="card" style="background:#0f1216">
      <h3 style="margin:0 0 8px 0">Perfis de preferência</h3>
      <div id="profiles"></div>
      <div class="row" style="margin-top:8px">
        <a class="btn" href="#" onclick="addProfile();return false;">Adicionar perfil</a>
        <a class="btn ghost" href="#" onclick="preset('simples');return false;">Preset: Simples</a>
        <a class="btn ghost" href="#" onclick="preset('ciclo');return false;">Preset: Ciclo</a>
      </div>
    </div>

    <div class="row" style="gap:8px">
      <a class="btn" href="#" onclick="runSim();return false;">Calcular</a>
      <a class="btn ghost" href="#" onclick="clearOutput();return false;">Limpar saída</a>
    </div>

    <div class="sep"></div>
    <div id="simOut"></div>
  </div>

  <div class="row" style="margin-top:10px">
    <a class="btn" href="{{ url_for('index') }}">Voltar ao início</a>
  </div>
</div>

<!-- ===== Scripts: alternador de modo + simulador Schulze ===== -->
<script>
  // ===== Alternador de modo =====
  function setMode(m){
    document.querySelectorAll('.mode-resumo,.mode-detalhado').forEach(el=>{
      el.style.display = (m==='resumo') ? (el.classList.contains('mode-resumo') ? '' : 'none')
                                        : (el.classList.contains('mode-detalhado') ? '' : 'none');
    });
    const tip = document.getElementById('modeTip');
    if(tip) tip.textContent = (m==='resumo') ? 'Exibindo a versão resumida.' : 'Exibindo a versão detalhada.';
    try{ localStorage.setItem('schulzeMode', m); }catch(e){}
  }
  (function initMode(){
    let m='resumo';
    try{ m = localStorage.getItem('schulzeMode') || 'resumo'; }catch(e){}
    setMode(m);
  })();

  // ===== Utilidades =====
  function el(tag, attrs={}, children=[]){
    const e = document.createElement(tag);
    Object.entries(attrs).forEach(([k,v])=>{
      if(k==='class') e.className=v;
      else if(k==='style' && typeof v==='object'){ Object.assign(e.style,v); }
      else e.setAttribute(k,v);
    });
    (Array.isArray(children)?children:[children]).forEach(c=>{
      e.appendChild(typeof c==='string'?document.createTextNode(c):c);
    });
    return e;
  }
  function byId(id){ return document.getElementById(id); }

  // ===== Estado do simulador =====
  let CANDS = ['A','B','C'];
  let PROFILES = []; // itens: { order:['A','B','C'], n: 1 }

  // ----- UI: candidatos
  function renderCands(){
    const cont = byId('candList'); if(!cont) return; cont.innerHTML='';
    CANDS.forEach((c,idx)=>{
      const pill = el('span',{class:'pill'},c);
      const rm = el('a',{href:'#',style:'margin-left:6px'},'remover');
      rm.onclick = (ev)=>{ ev.preventDefault();
        CANDS.splice(idx,1);
        // remove candidato também dos perfis
        PROFILES.forEach(p=>{ p.order = p.order.filter(x=>x!==c); });
        renderCands(); renderProfiles();
      };
      const box = el('div',{class:'row',style:'gap:6px;align-items:center;margin:4px 0'},[pill, rm]);
      cont.appendChild(box);
    });
  }
  function addCand(){
    const inp = byId('newCand');
    const v = (inp && inp.value || '').trim();
    if(!v) return;
    if(CANDS.includes(v)){ alert('Já existe.'); return; }
    CANDS.push(v);
    PROFILES.forEach(p=>{ if(!p.order.includes(v)) p.order.push(v); });
    if(inp) inp.value='';
    renderCands(); renderProfiles();
  }
  function resetCands(){
    CANDS=['A','B','C'];
    PROFILES=[];
    renderCands(); renderProfiles();
  }

  // ----- UI: perfis
  function renderProfiles(){
    const cont = byId('profiles'); if(!cont) return; cont.innerHTML='';
    // seed se vazio
    if(PROFILES.length===0){
      PROFILES = [
        {order:['A','B','C'], n:3},
        {order:['B','C','A'], n:2},
        {order:['C','A','B'], n:0},
      ];
    }
    PROFILES.forEach((p,idx)=>{
      const row = el('div',{class:'row',style:'gap:8px;flex-wrap:wrap;align-items:center;margin:6px 0'});

      // ordem editável (texto "A>B>C")
      const sel = el('input',{type:'text',value:p.order.join('>'),style:'min-width:220px'});
      sel.onchange = ()=>{
        const parts = sel.value.split('>').map(s=>s.trim()).filter(Boolean);
        // mantém apenas candidatos válidos e únicos, na ordem dada
        const seen = new Set(); const cleaned=[];
        parts.forEach(x=>{ if(CANDS.includes(x) && !seen.has(x)){ cleaned.push(x); seen.add(x); } });
        // adiciona faltantes ao final (ordem de CANDS)
        CANDS.forEach(x=>{ if(!seen.has(x)) cleaned.push(x); });
        p.order = cleaned;
      };

      // quantidade de eleitores
      const qty = el('input',{type:'number',min:'0',value:String(p.n||0),style:'width:110px'});
      qty.onchange = ()=>{ p.n = Math.max(0, parseInt(qty.value||'0',10)); };

      // botões
      const up = el('a',{href:'#',class:'btn ghost'},'↑');
      const dn = el('a',{href:'#',class:'btn ghost'},'↓');
      const rm = el('a',{href:'#',class:'btn ghost'},'remover');
      up.onclick=(ev)=>{ev.preventDefault(); if(idx>0){ const tmp=PROFILES[idx-1]; PROFILES[idx-1]=PROFILES[idx]; PROFILES[idx]=tmp; renderProfiles(); }};
      dn.onclick=(ev)=>{ev.preventDefault(); if(idx<PROFILES.length-1){ const tmp=PROFILES[idx+1]; PROFILES[idx+1]=PROFILES[idx]; PROFILES[idx]=tmp; renderProfiles(); }};
      rm.onclick=(ev)=>{ev.preventDefault(); PROFILES.splice(idx,1); renderProfiles(); };

      row.appendChild(el('span',{},'Ordem:')); row.appendChild(sel);
      row.appendChild(el('span',{},'Eleitores:')); row.appendChild(qty);
      row.appendChild(up); row.appendChild(dn); row.appendChild(rm);
      cont.appendChild(row);
    });
  }
  function addProfile(){ PROFILES.push({order:[...CANDS], n:1}); renderProfiles(); }

  // ----- Presets
  function preset(name){
    if(name==='simples'){
      CANDS=['A','B','C'];
      PROFILES=[ {order:['A','B','C'], n:3}, {order:['A','C','B'], n:2}, {order:['B','C','A'], n:0} ];
    }else if(name==='ciclo'){
      CANDS=['A','B','C'];
      PROFILES=[ {order:['A','B','C'], n:40}, {order:['B','C','A'], n:35}, {order:['C','A','B'], n:25} ];
    }
    renderCands(); renderProfiles(); runSim();
  }

  // ----- Cálculo Schulze
  function runSim(){
    if(CANDS.length<2){ alert('Adicione ao menos 2 candidatos.'); return; }
    // d[a][b] e p[a][b] (p = força de caminho)
    const d = {}; const p = {};
    CANDS.forEach(a=>{ d[a]={}; p[a]={}; CANDS.forEach(b=>{ if(a!==b){ d[a][b]=0; p[a][b]=0; } }); });

    // acumula preferências par-a-par a partir dos perfis
    PROFILES.forEach(pf=>{
      const pos={}; pf.order.forEach((c,i)=>pos[c]=i);
      CANDS.forEach(a=>{
        CANDS.forEach(b=>{
          if(a===b) return;
          if(pos[a] < pos[b]) d[a][b] += (pf.n||0);
        });
      });
    });

    // forças diretas
    CANDS.forEach(a=>{
      CANDS.forEach(b=>{
        if(a===b) return;
        p[a][b] = (d[a][b] > d[b][a]) ? d[a][b] : 0;
      });
    });

    // melhor caminho (Floyd-Warshall)
    CANDS.forEach(i=>{
      CANDS.forEach(j=>{
        if(i===j) return;
        CANDS.forEach(k=>{
          if(i===k || j===k) return;
          p[j][k] = Math.max(p[j][k], Math.min(p[j][i], p[i][k]));
        });
      });
    });

    // vencedores (não perdem para ninguém)
    const winners = CANDS.filter(x => CANDS.every(y => y===x || p[x][y] >= p[y][x]));

    // score auxiliar (wins/losses) para ordenação ilustrativa
    function score(x){
      let wins=0, losses=0;
      CANDS.forEach(y=>{
        if(y===x) return;
        if(p[x][y] > p[y][x]) wins++;
        else if(p[y][x] > p[x][y]) losses++;
      });
      return {wins, losses};
    }
    const ordered = [...CANDS].sort((a,b)=>{
      const A=score(a), B=score(b);
      if(A.wins!==B.wins) return B.wins - A.wins;
      return A.losses - B.losses;
    });

    // render
    const out = [];
    out.push('<div class="row" style="flex-wrap:wrap; gap:18px">');
    out.push('<div><b>Par-a-par (d[a][b])</b><br>'+renderMatrix(d)+'</div>');
    out.push('<div><b>Caminhos mais fortes (p[a][b])</b><br>'+renderMatrix(p)+'</div>');
    out.push('</div>');
    out.push('<p><b>Vencedor(es) de Schulze:</b> '+(winners.length? winners.join(', ') : '(nenhum)')+'</p>');
    out.push('<p class="muted"><b>Ordem ilustrativa</b> (wins, -losses): '+ordered.join(' &gt; ')+'</p>');
    const mount = byId('simOut'); if(mount) mount.innerHTML = out.join('');
  }

  function renderMatrix(m){
    let html = '<table class="table" style="border-collapse:collapse;border:1px solid var(--border)">';
    html += '<tr><th style="padding:6px;border:1px solid var(--border)"></th>';
    CANDS.forEach(c=> html+='<th style="padding:6px;border:1px solid var(--border)">'+c+'</th>');
    html += '</tr>';
    CANDS.forEach(a=>{
      html += '<tr><th style="padding:6px;border:1px solid var(--border)">'+a+'</th>';
      CANDS.forEach(b=>{
        const v = (a===b) ? '' : (m[a] && typeof m[a][b] !== 'undefined' ? m[a][b] : '');
        html += '<td style="padding:6px;border:1px solid var(--border);text-align:center">'+v+'</td>';
      });
      html += '</tr>';
    });
    html += '</table>';
    return html;
  }

  function clearOutput(){
    const m = byId('simOut'); if(m) m.innerHTML='';
  }

  // inicialização
  renderCands();
  renderProfiles();
  runSim();
</script>
{% endblock %}
